import 'dart:convert';
import 'dart:ffi' as ffi;
import 'dart:io';
import 'package:ffi/ffi.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:snag_report_extractor_app/src/logging/talker.dart';
import 'mupdf_ffi.g.dart'; // generated by ffigen
import 'package:snag_report_extractor_app/src/features/pdf_extractor/domain/mupdf.dart';

class MuPdfRepository {
  late final MuPDFBindings _b;

  MuPdfRepository._(this._b);

  static MuPdfRepository initialize() {
    talker.debug('Initializing MuPdfRepository...');
    final lib = ffi.DynamicLibrary.open(_getLibraryPath());
    final bindings = MuPDFBindings(lib);
    talker.info('MuPdfRepository initialized with bindings');

    return MuPdfRepository._(bindings);
  }

  int getPageCount(String path) {
    final pathPtr = path.toNativeUtf8();
    try {
      final pageCount = _b.mw_count_pages(pathPtr.cast<ffi.Char>());
      talker.info('PDF "$path" has $pageCount pages');
      return pageCount;
    } catch (e, st) {
      talker.error('Error getting page count: $e', e, st);
      rethrow;
    } finally {
      malloc.free(pathPtr);
    }
  }

  Map<String, dynamic> extractAllJson(String path, bool includeImgData) {
    talker.debug("extractAllJson called with includeImgData=$includeImgData");

    final pageCount = getPageCount(path);

    List<MuPdfPage> pages = [];
    try {
      for (int page = 1; page <= pageCount; page++) {
        talker.verbose('Extracting JSON for page $page');
        final muPdfPage = extractPageJson(path, page, includeImgData);
        pages.add(muPdfPage);
      }
    } catch (e, st) {
      talker.error('Error extracting PDF JSON: $e', e, st);
      rethrow;
    }

    return {
      'page_count': pageCount,
      'pages': pages,
    };
  }

  MuPdfPage extractPageJson(String path, int page, bool includeImgData) {

    ffi.Pointer<Utf8> pathPtr = ffi.nullptr;
    ffi.Pointer<ffi.Char> cStrPtr = ffi.nullptr;
    talker.debug(
      "extractPageJson called with page=$page includeImgData=$includeImgData",
    );
    try {
      pathPtr = path.toNativeUtf8();
      cStrPtr = _b.extract_page_json(pathPtr.cast<ffi.Char>(), page, includeImgData);
      if (cStrPtr.address == 0) {
        final error = _lastError();
        talker.error('Null pointer returned for page $page: $error');
        throw StateError(
          'Failed to extract page $page JSON: ${error ?? "Unknown error"}',
        );
      }
      final dartStr = cStrPtr.cast<Utf8>().toDartString();
      if (dartStr.isEmpty) {
        talker.error('Empty JSON returned for page $page');
        throw StateError('Empty JSON returned for page $page');
      }
      final json = jsonDecode(dartStr) as Map<String, dynamic>;
      if (!includeImgData) {
        talker.verbose('Successfully parsed JSON for page $page');
      }
      return MuPdfPage.fromJson(page, json);
    } catch (e, st) {
      talker.error('Error extracting page $page: $e', e, st);
      rethrow;
    } finally {
      // Clean up native memory
      if (pathPtr.address != 0) {
        malloc.free(pathPtr);
      }
      if (cStrPtr.address != 0) {
        _b.mw_free_string(cStrPtr);
      }
    }
  }

  String? _lastError() {
    final ptr = _b.mw_get_last_error();
    if (ptr.address == 0) return null;
    final msg = ptr.cast<Utf8>().toDartString();
    return msg.isEmpty ? null : msg;
  }

  static String _getLibraryPath() {
    if (Platform.isWindows) {
      return 'mupdf_wrapper.dll';
    } else if (Platform.isMacOS) {
      return 'libmupdf_wrapper.dylib';
    } else {
      return 'libmupdf.so';
    }
  }
}

final muPdfRepositoryProvider = Provider<MuPdfRepository>((ref) {
  return MuPdfRepository.initialize();
});