import 'dart:convert';
import 'dart:ffi' as ffi;
import 'dart:io';
import 'package:ffi/ffi.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'mupdf_ffi.g.dart'; // generated by ffigen
import 'package:snag_report_extractor_app/src/features/pdf_extractor/domain/mupdf.dart';

class MuPdfRepository {
  late final MuPDFBindings _b;

  MuPdfRepository._(this._b);

  static MuPdfRepository initialize() {
    final lib = ffi.DynamicLibrary.open(_getLibraryPath());
    final bindings = MuPDFBindings(lib);

    return MuPdfRepository._(bindings);
  }

  int getPageCount(String path) {
    final pathPtr = path.toNativeUtf8();
    try {
      final pageCount = _b.mw_count_pages(pathPtr.cast<ffi.Char>());
      return pageCount;
    } catch (e) {
      print('Error getting page count: $e');
      return 0;
    } finally {
      malloc.free(pathPtr);
    }
  }

  Map<String, dynamic> extractAllJson(String path, bool includeImgData) {
    print("extractAllJson called");
    print("includeImgData: $includeImgData");
    final pageCount = getPageCount(path);

    List<MuPdfPage> pages = [];
    try {
      for (int page = 1; page <= pageCount; page++) {
        final muPdfPage = extractPageJson(path, page, includeImgData);
        pages.add(muPdfPage);
      }
    } catch (e) {
      print('Error extracting PDF JSON: $e');
    }

    return {
      'page_count': pageCount,
      'pages': pages,
    };
  }

  MuPdfPage extractPageJson(String path, int page, bool includeImgData) {

    ffi.Pointer<Utf8> pathPtr = ffi.nullptr;
    ffi.Pointer<ffi.Char> cStrPtr = ffi.nullptr;
    print("extractPageJson with Page No. $page");
    try {
      pathPtr = path.toNativeUtf8();
      cStrPtr = _b.extract_page_json(pathPtr.cast<ffi.Char>(), page, includeImgData);
      if (cStrPtr.address == 0) {
        final error = _lastError();
        print(error);
        throw StateError(
          'Failed to extract page $page JSON: ${error ?? "Unknown error"}',
        );
      }
      final dartStr = cStrPtr.cast<Utf8>().toDartString();
      if (dartStr.isEmpty) {
        throw StateError('Empty JSON returned for page $page');
      }
      final json = jsonDecode(dartStr) as Map<String, dynamic>;
      return MuPdfPage.fromJson(page, json);
    } catch (e) {
      print('Error extracting page $page: $e');
      rethrow;
    } finally {
      // Clean up native memory
      if (pathPtr.address != 0) {
        malloc.free(pathPtr);
      }
      if (cStrPtr.address != 0) {
        print('Freeing C string pointer for page $page');
        _b.mw_free_string(cStrPtr);
      }
    }
  }

  String? _lastError() {
    final ptr = _b.mw_get_last_error();
    if (ptr.address == 0) return null;
    final msg = ptr.cast<Utf8>().toDartString();
    return msg.isEmpty ? null : msg;
  }

  static String _getLibraryPath() {
    if (Platform.isWindows) {
      return 'mupdf_wrapper.dll';
    } else if (Platform.isMacOS) {
      return 'libmupdf_wrapper.dylib';
    } else {
      return 'libmupdf.so';
    }
  }
}

final muPdfRepositoryProvider = Provider<MuPdfRepository>((ref) {
  return MuPdfRepository.initialize();
});